## 标量与矢量数据包处理
FD.io VPP是使用矢量包处理而非标量包处理开发的。

矢量数据包处理是高性能数据包处理应用程序（例如FD.io VPP和DPDK）中的常用方法。基于标量的方法往往受到没有严格性能要求的网络堆栈的青睐。

### 标量数据包处理

标量数据包处理网络堆栈通常一次处理一个数据包：中断处理功能从网络接口获取单个数据包，并通过一组功能对其进行处理：fooA调用fooB调用fooC等等。

```
+---> fooA（packet1）+---> fooB（packet1）+---> fooC（packet1）
+---> fooA（packet2）+---> fooB（packet2）+---> fooC（packet2）
...
+---> fooA（packet3）+---> fooB（packet3）+---> fooC（packet3）
```

标量数据包处理很简单，但是在以下方面效率低下：

* 当代码路径长度超过微处理器指令高速缓存（I-cache）的大小时，微处理器将不断加载新指令，从而发生抖动。在此模型中，每个数据包都会产生相同的I缓存未命中集。
* 当堆栈局部内存落入微处理器的第1层数据缓存（D-cache）时，关联的深度调用堆栈还将增加负载存储单元的压力。

### 矢量数据包处理

相反，矢量数据包处理网络堆栈一次处理多个数据包，称为“数据包矢量”或简称为“矢量”。中断处理函数从网络接口获取数据包的向量，并通过一组函数处理该向量：fooA调用fooB调用fooC等等。

```
+---> fooA（[packet1，+---> fooB（[packet1，+---> fooC（[packet1，+ --->
             packet2，            packet2，             packet2，
             ...                  ...                  ...
             packet256]）         packet256]）          packet256]）
```

此方法可修复：

* 通过分摊多个数据包中I-cache负载的成本，上述的I-cache抖动问题。
* 通过一次从网络接口接收多达256个数据包的向量，并使用节点的有向图对其进行处理，从而与深度调用堆栈相关联的效率低下。图调度程序一次调用一个节点调度功能，将堆栈深度限制为几个堆栈帧。
* 这种方法实现的进一步优化是流水线处理和预取，以最大程度地减少表数据的读取延迟并并行化处理数据包所需的数据包负载。
