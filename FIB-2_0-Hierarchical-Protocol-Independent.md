## FIB2.0分层协议
### 预备知识(Prerequisites)

本节描述一些FIB架构基础的先决条件和术语解释
#### 图(Graphs)
FIB本质上是相关图的集合。维基百科上的推论术语通常用于接下来的章节：

_...图表示一组对象的集合，对象之间建立了连接。相互连接的对象在数学上被抽象的叫做顶点(或节点、点)，顶点之间的连接叫做边(或弧、线)，边可以是有向的或者无向的..._

在有向图中，边只能朝一个方向遍历-从子节点到父节点，选择名称以表示多对一的关系。一个子节点有一个父节点，但一个父节点可以有多个子节点。在无向图中，遍历可以从任一方向开始，但在FIB中，父子命令法仍代表了多对一的关系。具有相同父节点的子节点称之为兄弟节点。如果遍历是从子节点到父节点，则被视为向前遍历(Forward Traversal)或步进(Walk)，而从父节点到子节点的遍历被视为向后遍历(Back Walk)。向前遍历成本很小，因为它是从多少少，而从少到多成本就很高。

子节点与父节点之间的多对一关系意味着父节点的生存期必须延长到其子节点的生存期。 如果控制平面在其子节点之前删除了父节点，则父节点必须保持不完整状态，直到子节点本身被删除为止。 同样，如果在其父节点之前创建了一个子节点，则父节点会以未完成状态完成。 需要这些不完整的对象来维护图依赖性。 如果没有它们，则在添加父节点时发现受影响的子节点将通过许多数据库搜索这些子节点。 为了延长父节点的寿命，其所有子节点必须锁定父节点。 这是一个简单的参考计数。 然后，子节点遵循添加或锁定/解锁语义来查找父节点，而不是malloc/free。

#### 前缀(Prefixs)
一些描述前缀的术语:
* 1.1.1.1 这是一个地址,因为没有与它相关联的掩码
* 1.1.1.0/24 这是一个前缀
* 1.1.1.1/32 这是一个主机前缀(掩码长度是地址的长度)

如果前缀A的掩码长度比前缀B的掩码长度长，则前缀A更具体；反之，前缀越短则越不具体，例如: 1.1.1.0/28比1.1.1.0/24更具体。

一个不具体的前缀覆盖范围包括具体的前缀覆盖范围，称之为覆盖前缀(Covering Prefix)，例如: 1.1.1.0/24覆盖1.1.1.0/28，1.1.1.0/28称之为被覆盖前缀(Covered Prefix)，因此，覆盖前缀一定比被覆盖前缀更不具体。

### 数据模型(The Data Model)
FIB数据模型包括两个部分：控制平面(CP)和数据平面(DP)。控制平面数据模型表示由上层编程到VPP中的数据。数据平面模型表示VPP如何在交换数据包时派生对数据包执行的操作。
#### 控制平面(The Control Plane)
控制平面遵循分层数据表示。本文档介绍了从最低层开始的模型。该描述使用IPv4地址和协议，但是所有概念均等同地适用于IPv6。这些图都描绘了用于在VPP中安装信息的CLI命令以及用于表示该信息的数据结构的UML图的近似图。

* ARP条目(ARP Entries)

  ![ARP数据模型](https://github.com/penybai/vpp-docs/blob/master/images/arp-entries.png)
  图1：ARP数据模型

  图1显示了ARP条目的数据模型。ARP条目包含由IPv4地址标识的对等方(peer)与其给定接口上的MAC地址之间的映射。接口绑定的VRF，不是数据的一部分。VRF是入口函数，而不是出口。ARP条目描述了如何向对等方发送流量，这是一种出口功能。

  arp_entry_t表示在控制平面上添加的ARP条目。ip_adjacency_t包含从arp_entry_t派生的数据，这些数据是将数据包转发到对等方所需要的。邻接中的其他数据是rewrite和link_type。link_type是需要邻居转发的数据包中的协议描述，可以是IPv4或MPLS。link_type直接映射到以太网头中的以太类型，或GRE头中归档的协议。rewrite是报头的字节字符串表示形式，当发送到该对等方时，该报头将附加在该数据包之前。对于以太网接口，这将是src、dst MAC和ether-type。对于LISP隧道，使用IP src、dst对和LISP头。

  创建条目时，arp_entry_t将安装link_type = IPv4，而当接口启用MPLS时将安装link_type = MPLS。出于安全原因，必须为接口明确启用MPLS。

  这样就可以在路由之间共享邻接关系，将邻接关系存储在一个数据库中，该数据库的关键字为{interface，next-hop，link-type}。

* 路由(Routes)

  控制平面将通过路径列表在表中为前缀安装路由。FIB的主要功能是解决该路由。解决一条路线就是构造一个对象图，该图完全描述路线的所有元素。在图3中，解决了从fib_entry_t到ip_adjacency_t的图的完整过程。

  在某些路由模型中，VRF将由一组用于IPv4和IPv6以及单播和多播的表组成。在VPP中，没有这样的分组。每个表彼此不同。表格由其数字ID标识。每个地址系列的ID范围都是独立的。

  一个表由两个路由数据库组成，转发和非转发。转发数据库包含路由，数据包将针对这些路由执行数据平面中的最长前缀匹配(LPM)。非转发数据库包含已使用VPP编程的所有路由，其中​​某些路由可能由于无法阻止其插入转发数据库的原因而无法解析(请参阅：[邻接源FIB条目]())。

  路由数据被分解为三部分：条目(entry)、路径列表(path-list)和路径(paths)：
  > * fib_entry_t（包含路由前缀）是FIB表中该前缀条目的表示。
  > * fib_path_t描述了将数据包发送到路由前缀的位置。有几种类型的路径。 
    > > * 附加的下一跳(Attached Next-hop)：使用接口(interface)和下一跳(next-hop)描述路径。下一跳与该接口上路由器自身地址位于同一子网中，因此认为对等体已连接。
    > > * 附加(Attached)：仅通过接口(interface)描述路径。前缀覆盖的所有地址都在该路由器接口所连接的同一个L2网段上。这意味着可以对前缀所覆盖的任何地址进行ARP，而通常情况并非如此（因此，IOS中的代理ARP崩溃）。附加路径仅适用于不需要ARP的点对点(P2P)接口，即GRE隧道。
    > > * 递归(Recursive)：仅通过next-hop和table-id来描述路径。
    > > * 解聚合(De-aggregate)：仅通过特殊的全零地址和一个表ID来描述路径。这意味着应在表中进行后续查找。
  > * fib_path_list_t代表转发时从中选择路径的路径列表。路径列表是共享对象，即它是多个fib_entry_t子代的父代。为了共享任何对象类型，子节点必须搜索符合其要求的现有对象。为此，必须有一个数据库。路径列表数据库的关键是对它包含的所有路径的组合描述。每次添加路由时都需要搜索路径列表数据库，因此仅填充共享将带来共享的路径列表。融合优势（请参阅部分：[快速融合]()）。

  ![路由数据模型类图](https://github.com/penybai/vpp-docs/blob/master/images/route-data-model-class-diagram.png)
  图2: 路由数据模型类图

  图2显示了一条具有两条连接的下一跳路径的路由示例。这些路径中的每条路径都将通过找到与路径属性匹配的邻接关系来解决，该属性与邻接数据库的关键字相同。转发信息（FI）是在数据平面中可用于负载均衡流量的邻接关系集。路径为路由的转发信息提供了邻接关系，路径列表为IP数据包提供了完整的转发信息。

  ![路由对象图](https://github.com/penybai/vpp-docs/blob/master/images/route-object-diagram.png)
  图3: 路由对象图

  图3显示了为解析路由而创建的对象实例及其关系。这些关系的图形性质显而易见。在图的顶部显示子节点，在其下方显示父节点。因此，向前走是从上到下，向后走是从下到上。该图显示了共享的对象，路径列表和邻接关系。共享对象对于快速收敛至关重要（请参阅：[快速收敛]()部分）。

  - FIB源(FIB sources)
  
  系统中可以将各种路由添加到FIB表的实体。这些实体中的每个实体都称为源。当不同的源添加相同的前缀时，FIB必须在它们之间进行仲裁，以确定哪个源将贡献转发信息。由于每个源使用不同的最佳路径和环路预防算法来确定转发信息，因此将多个源的转发信息组合在一起是不正确的。相反，FIB必须选择仅使用来自一个来源的转发信息。该选择基于静态优先级分配。FIB必须维护每个来源添加的信息，以便在该来源成为最佳来源时可以还原该信息。VPP有两个控制平面源: API和CLI，其中API的优先级较高。每个源数据都由fib_entry_src_t对象表示，该对象由fib_entry_t维护排序后的向量，当接口连接时将前缀应用于该接口。

  配置如下：

  > set interface 192.168.1.1/24 GigabitEthernet0/8/0

  结果增加了两个FIB条目；192.168.1.0/24是已连接(Connected)并附加(Attached)的，以及192.168.1.1/32是已连接(Connected)并是本地(Local)的（又称接收或使用）。这两个前缀都是接口来源(interface sourced)的。接口源具有较高的优先级，因此意外或恶意添加相同的前缀不会阻止路由器正确转发。匹配所连接前缀的数据包将为数据包目标地址生成ARP请求，此过程称为收集(glean)。

  附加的前缀也会产生glean，但路由器在该子网中没有自己的地址。以下配置将产生一条附加路由，该路由通过一条附加路径进行解析:

  > ip route add table X 10.10.10.0/24 via gre0

  如前所述，这些仅适用于点对点链接(Ponit-to-Point)。附加主机前缀(attached-host prefix)被附加前缀(attached prefix)覆盖（请注意，已附加连接前缀）。如果表X不是gre0绑定到的表，那么附加导出就是这种情况（请参见：[附加导出]()一节）。

  - 邻接源FIB条目(Adjacency source FIB entries)

  无论何时一个ARP条目被创建时，它将引出一条fib_entry_t，在这种情况下，路由是这种形式：

  > ip route add table X 10.0.0.1/32 via 10.0.0.1 GigabitEthernet0/8/0
  
  它是一个主机前缀(host prefix)，其路径的下一跳地址相同。该路由强调了路由前缀（要匹配的流量的描述）和路径（匹配的流量的发送位置）之间的区别。 表X是接口绑定到的同一表。由邻接来源产生的FIB条目称为邻接fib。邻接源的优先级低于API源，因此以下配置：

  > set interface address 192.168.1.1/24 GigabitEthernet0/8/0
  > ip arp 192.168.1.2 GigabitEthernet0/8/0 dead.dead.dead
  > ip route add 192.168.1.2 via 10.10.10.10 GigabitEthernet1/8/0

  将通过GigabitEthernet1/8/0转发192.168.1.2的流量。也就是说，控制平面添加的路由比ARP发现的邻接更受青睐。控制平面及其相关的身份验证被视为权威来源。为了通过恶意注入邻接来抵消有害添加的恶作剧，FIB还需要确保在转发中仅安装附有覆盖范围较小的前缀的adj-fib。这需要使用覆盖跟踪，其中路由与路由的依存关系（即其覆盖性较弱）保持依赖关系。当此覆盖更改（即有一条新的覆盖路线）或更新了覆盖的转发信息时，便会通知该覆盖路线。未通过这项覆盖检查的adj-fib不会安装到fib_table_t的转发表中，仅存在于非转发表中。

  不支持重叠子网，因此没有adj-fib具有多个路径。在接口更改RF之前，控制平面会删除为接口配置的前缀。

  因此，如下配置是可以被接受的: 

  > set interface address 192.168.1.1/32 GigabitEthernet0/8/0
  > ip arp 192.168.1.2 GigabitEthernet0/8/0 dead.dead.dead
  > set interface ip table GigabitEthernet0/8/0 2

  它不会导致期望的行为，它会将adj-fib和连接的邻接关系移至表2。

  - 递归路由(Recursive Routes)

  图4显示了用于描述递归路由的数据结构。该表示几乎与连接的下一跳路径相同。区别在于，fib_path_t的父级是另一个fib_entry_t，称为通行条目(via-entry)。

  ![递归路由类图](https://github.com/penybai/vpp-docs/blob/master/images/recursive-route-class-diagram.png)
  图4: 递归路由类图

  为了将流量转发到64.10.128.0/20，FIB必须首先确定如何将流量转发到1.1.1.1/32。这是递归解析。递归解析本质上是数据平面结果的缓存，它模拟via-table表0中“via-address”1.1.1.1的最长前缀匹配(LPM)。

  递归解析（RR）将在通行表(via-table)中为通行地址(via-address)产生主机前缀(host-prefix)条目。RR源是低优先级源，它不会成为最好的源，因为如果在这种情况下，它必须从其覆盖前缀中获取转发信息。

  有两种情况需要考虑：

  > * 覆盖已连接。via-address是连接的主机，并且RR源可以通过键{via-address，interface-of-connected-cover}通过邻接关系直接解析。
  > * 覆盖未连接。 RR源可以直接从其覆盖继承转发信息。
  对覆盖前缀的这种依赖性意味着RR源将跟踪其覆盖，覆盖前缀在下边两种情况下将改变:
  > * 插入一个更具体的前缀。因此，无论何时将条目插入FIB表中，都必须找到其覆盖，以便可以通知其所覆盖的家属。
  > * 现有的覆盖已经移除。覆盖的前缀必须与下一个较不具体的前缀形成新的关系。

  修改覆盖前缀的路由时，将更新覆盖。覆盖跟踪机制将在更改或更新覆盖的情况下向RR源条目提供通知，并且源可以采取必要的措施。

  源自RR的FIB条目成为fib_path_t的父级，并将其转发信息贡献给该路径，以便子级的FIB条目可以构造自己的转发信息。

  图5显示了创建的对象实例，以表示递归路线及其解析路线。

  ![递归路由对象图](https://github.com/penybai/vpp-docs/blob/master/images/recursive-routes-object-diagram.png)
  图5: 递归路由对象图

  如果添加递归路由的源代码本身未执行递归解析，则该源代码可能会无意中编写了递归循环。

  递归循环的一个示例配置如下：

  > ip route add 5.5.5.5/32 via 6.6.6.6
  > ip route add 6.6.6.6/32 via 7.7.7.7
  > ip route add 7.7.7.7/32 via 5.5.5.5

  这显示了三个级别上的循环，但任何数量都可以。当fib_entry_t与fib_path_list_t形成子对父关系时，FIB将通过向前遍历图来检测递归循环。遍历检查是否遇到相同的对象实例。当形成递归循环时，控制平面的图变为循环的，从而允许形成子对父项的依存关系。这是必要的，以便在循环中断时，受影响的孩子可以得到更新。

  - 输出标签(Output Labels)
  
  一条路由可能已关联了MPLS标签。这些标签是在转发数据包时应施加在标签上的。重要的是要注意，MPLS标签是按路由和按路径的，因此，即使路由共享路径，它们也不一定具有该路径的相同标签。因此，标签唯一地与fib_entry_t关联并与它转发到的fib_path_t之一。MPLS标签是通过路径扩展的通用概念建模的。因此，fib_entry_t的向量为0到多个fib_path_ext_t对象，以表示配置该标签的标签。

* 附加导出(Attached Export)
* 图遍历(Graph Walks)

#### 数据平面(The Data Plane)
数据平面数据模型是异构对象的有向无环图。数据包在交换时按照图往前走。每个对象都描述了要对数据包执行的操作。每种对象类型都有一个关联的VLIB图节点。因此，对于一个要向前走的数据包，该图是从一个VLIB节点移动到下一个，每个节点都执行所需的操作。这是VPP模型的核心。

数据平面图由通用数据路径对象（data-path-objects,DPOs）组成。父DPO由元组标识：{type，index，next_node}。next_node参数是数据包接下来应发送到的VLIB节点的索引，此参数用于最大程度地提高性能-这对于确保在处理子级时无需读取父级很重要。DPO专业执行不同的操作。最常见的DPO及其简要表示为：

* 负载均衡(Load-Balance)：ECMP集中的一种选择。
* 邻接(Adjacency)：通过接口进行重写和转发。
* MPLS标签(MPLS Label)：强加MPLS标签。
* 查找(Lookup)：在不同的表中执行查找。
  
数据平面图由控制平面图通过其中的对象将DPO“贡献”到数据平面图而得出。数据平面中的对象仅包含交换数据包所需的信息，因此它们更简单，并且在内存方面更小，目的是将一个DPO放在单个高速缓存行上。从控制平面派生意味着数据平面图仅包含其当前状态可以转发数据包的对象。 例如，fib_path_list_t和load_balance_t之间的区别在于，前者表示控制平面的期望状态，后者表示数据平面的可用状态。如果路径列表中的某些路径未解析或关闭，则负载平衡将不将其包括在转发选项中。

![非递归路由的DPO贡献](https://github.com/penybai/vpp-docs/blob/master/images/dpo-contributions-for-a-non-recursive-route.png)
图8：非递归路由的DPO贡献

图8显示了控制平面图的简化视图，表明了贡献DPO的那些对象。还显示了使用DPO的VLIB节点图。

每个fib_entry_t都贡献自己的load_balance_t，其原因有三个：

* 在IPv[46]表中查找的结果是一个32位无符号整数。这是内存池的索引。因此，每个结果的对象类型必须相同。有些路由需要负载均衡，有些则不需要，但是在图中插入另一个对象来表示此选择会浪费周期，因此负载均衡对象始终是结果。如果路由没有ECMP，则负载平衡只有一种选择。

* 为了收集每个路由计数器，查找结果必须以某种方式唯一地标识fib_entry_t。共享的负载平衡（由路径列表提供）将不允许这样做。

* 在fib_entry_t具有MPLS输出标签的情况下，因此具有fib_path_ext_t，则负载平衡必须是按前缀的，因为作为其父级的MPLS标签本身就是per-fib_entry_t。
  
![递归路线由DPO贡献](https://github.com/penybai/vpp-docs/blob/master/images/dpo-contributions-for-a-recursive-route.png)
图9：递归路由的DPO贡献

图9显示了递归路由贡献的负载均衡对象。

![来自标签的递归路由的DPO贡献](https://github.com/penybai/vpp-docs/blob/master/images/dpo-contributions-from-labelled-recursive-routes.png)
图10：来自标签的递归路由的DPO贡献

图10显示了标记的递归路由的派生数据平面图。MPLS标签DPO实例的数量可以与路由数乘以每个路由的路径数一样多。因此，mpls-label DPO应该尽可能小。

数据平面图是通过将DPO的一个实例“堆叠”在另一个实例上以形成子代-父级关系而构造的。发生这种堆叠时，将根据相关DPO类型的已注册图形节点自动构建必要的VLIB图形弧。

上图显示，对于任何给定的路由，在任何数据包到达之前就已经知道完整的数据平面图。如果该图由n个对象组成，则该数据包将访问n个节点，从而导致转发成本约为图节点成本的n倍。如果将图形折叠到单个DPO和关联的节点中，则可以减少这种情况。但是，折叠图形会删除提供快速收敛的间接对象（请参见：[快速收敛]()部分）。崩溃是快速转发和快速收敛之间的权衡；VPP支持后者。

这种DPO模型今天有效地存在，但是是非正式定义的。目前，数据平面中唯一的对象是ip_adjacency_t，但是功能（例如ILA，逐跳OAM，SR，MAP等）将邻接类型归为子类型。成员lookup_next_index等效于定义新的子类型。添加到现有的并集或将子类型特定的数据强制转换为不透明成员，甚至覆盖重写字符串（例如新的端口范围检查器），都等同于定义新的C结构类型。幸运的是，这时所有这些子类型的内存都小于ip_adjacency_t。现在可以使用ip_register_adjacency()动态注册新的邻接子类型，并提供自定义格式功能。

我认为，严格定义的对象模型将使贡献者更容易理解，并且实现起来更健壮。