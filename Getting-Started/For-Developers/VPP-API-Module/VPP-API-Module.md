## VPP API模块

### 概览

VPP API模块允许通过共享内存接口与VPP通信。该API包含3部分：
* 通用代码-低级API
* 生成的代码-高级API
* 代码生成器-生成你自己的高级API，例如用于自定义插件

### 通用代码

**C**

C通用代码表示基本的低级API，提供连接/断开连接，执行消息发现以及发送/接收消息的功能。C变量位于vapi.h中。

**C++**

C++由vapi.hpp提供，并包含高级API模板，这些模板由生成的代码专用。

### 生成的代码
源代码树中存在的每个API文件都会自动转换为JSON文件，代码生成器会解析并生成C（vapi_c_gen.py）或C++（vapi_cpp_gen.py）代码。

然后可以将其包含在客户端应用程序中，并提供与VPP交互的便捷方法。这包括：
* 自动字节转换
* 基于上下文的自动请求-响应匹配
* 调用回调时自动强制转换为适当的类型（类型安全）
* 自动发送转储信息的control-pings

API支持两种操作模式：
* 阻塞
* 非阻塞

在阻塞模式下，每当启动操作时，代码就会等待，直到操作完成为止。这意味着在发送消息时，调用将阻塞，直到可以将消息写入共享内存为止。同样，接收消息会阻塞，直到有消息可用为止。在更高级别上，这还意味着在执行请求（例如show_version）时，调用将阻塞直到响应返回（例如show_version_reply）。

在非阻塞模式下，它们是解耦的，只要无法执行操作，API就会返回VAPI_EAGAIN，并且在发送请求后，由客户端来等待和处理响应。

### 代码生成器
Python代码生成器有两种形式-C和C++，并生成高级API头文件。所有代码都存储在头文件中。

### C用法
**低级API**

有关功能的描述，请参阅vapi.h头文件中doxygen格式的内联API文档。建议使用专用头文件（例如vpe.api.vapi.h或vpe.api.vapi.hpp）提供的更安全的高级API。

**C高级API**

***回调***

C高级API严格基于回调，以实现最高效率。每当启动操作时，带有回调上下文的回调就是该操作的一部分。然后，当响应（或多个响应）与请求绑定在一起时，将调用回调。另外，如果事件已注册，则每当事件到达时都会调用回调。所有指向响应/事件的指针都指向共享内存，并在回调完成后立即释放，因此客户端需要提取/复制其感兴趣的任何数据。

**阻塞模式**

在简单阻塞模式下，整个操作（无论是简单的请求还是转储）都已完成，并且在函数调用期间调用了其回调（转储可能多次）。

在这种模式下，一个简单请求的伪代码示例：

vapi_show_version(message，callback，callback_context)
1. 生成唯一的内部上下文并将其分配给message.header.context
2. 将消息转换为网络字节顺序
3. 向vpp发送消息（现在消息已被消费，vpp将释放它）
4. 创建内部“未完成的请求上下文”，其中保存了回调，回调上下文和内部上下文值
5. 呼叫分派(dispatch)，在这种模式下，它接收并处理响应，直到内部“未解决的请求”队列为空。在阻塞模式下，此队列始终最多包含一项。

> 注意：在某些情况下，调用响应回调之前可能会调用不同的-不相关的回调。事件存储在共享内存队列中。

**非阻塞模式** 在非阻塞模式下，所有请求仅被字节转换，并且上下文信息和回调一起存储在本地（因此，在以上示例中，仅执行步骤1-4，而跳过了步骤5）。调用调度取决于客户端应用程序。这允许在发送/接收消息之间交替或具有专用线程来调用调度。

### C++高级API

**回调**

在C++API中，响应自动绑定到相应的Request，Dump或Event_registration对象。可以选择指定一个回调，然后在收到响应时调用该回调。

> 注意：响应占用共享的内存空间，应在不再需要时手动释放（对于结果集）或自动释放（通过销毁拥有它们的对象）。一旦执行了Request或Dump对象，就无法重新发送该对象，因为该请求本身（存储在共享内存中）已被vpp占用，并且无法访问（设置为nullptr）。

### C++用法

**Requests和dumps**

***创建一个Connection类型的对象，并调用connect()以连接到vpp。***

1. 使用typedef（例如Show_version）创建请求或转储类型的对象
2. 如果需要，使用get_request()获取和处理基础请求。
3. 发出execute()发送请求。
4. 使用wait_for_response()或dispatch()等待响应。
5. 使用get_response_state()获取状态，并使用get_response()读取响应。

**Events**

***创建连接并执行适当的请求以订阅事件（例如，Want_stats）***

1. 使用模板参数为您感兴趣的事件类型创建Event_registration。
2. 调用dispatch()或wait_for_response()等待事件。事件发生时（如果传递给Event_registration()构造函数），将调用回调。或者，读取结果集。

> 注意: 结果集中存储的事件会占用共享内存中的空间，应定期释放（例如，在处理事件后在回调中释放）。